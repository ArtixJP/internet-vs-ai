<!DOCTYPE html>

<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<title>City Walker</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a0a12; }
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        #info h1 { font-size: 24px; margin-bottom: 5px; }
        #population {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #ff00ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-shadow: 0 0 8px #ff00ff;
            z-index: 100;
        }
        #community-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.7;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="info">
<h1>üåÉ CITY WALKER</h1>
<span>Follow the journey through neon streets</span>
</div>
<div id="population">CITIZENS: <span id="count">0</span></div>
<div id="community-zone">üó£Ô∏è Citizens respawn! | üíª NPCs typing while walking | üé¨ Attack cam focus | üíÄ EVIL TMNT hunting prey | üéµ Click for synthwave</div>
<div id="speech-bubble" style="position:absolute;display:none;background:rgba(0,0,0,0.85);color:#fff;font-family:'Courier New',monospace;font-size:12px;padding:10px 15px;border-radius:10px;border:2px solid #00ffff;max-width:250px;z-index:200;pointer-events:none;box-shadow:0 0 15px rgba(0,255,255,0.5);"><span id="bubble-text"></span></div>
<div id="debug" style="position:absolute;top:60px;left:20px;color:#00ff00;font-family:monospace;font-size:11px;z-index:100;background:rgba(0,0,0,0.5);padding:8px;border:1px solid #00ff00;">üîß DEBUG: Scene Active<br/>Manhattan Grid: Optimized | NPCs: 24<br/>Renderer: WebGL | üê¢ TMNT Active<br/>‚úÖ Lights: 4 total | üìä Memory Optimized<br/>üéØ Frustum Culling: <span id="cull-stats">Active</span></div>
<div id="turtle-status" style="position:absolute;top:130px;left:20px;color:#ff0000;font-family:monospace;font-size:11px;z-index:100;background:rgba(100,0,0,0.5);padding:8px;border:1px solid #ff0000;">üê¢ EVIL Ninja Turtles: Hunting... üíÄ</div>
<div id="kill-count" style="position:absolute;top:170px;left:20px;color:#ff4444;font-family:monospace;font-size:11px;z-index:100;background:rgba(50,0,0,0.5);padding:8px;border:1px solid #ff4444;">‚ò†Ô∏è VICTIMS: <span id="victims">0</span></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        // üéµ SYNTHWAVE CITY SOUNDTRACK üéµ
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicIntervals = [];
        
        // Musical scales for cyberpunk vibes (A minor pentatonic + extras)
        const bassNotes = [55, 65.41, 73.42, 82.41, 98, 110]; // A1, C2, D2, E2, G2, A2
        const arpNotes = [220, 261.63, 293.66, 329.63, 392, 440, 523.25, 587.33]; // A3-D5
        const padNotes = [110, 130.81, 146.83, 164.81]; // A2, C3, D3, E3
        
        // Master volume control
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4;
        masterGain.connect(audioCtx.destination);
        
        // Reverb for atmosphere
        const convolver = audioCtx.createConvolver();
        const reverbTime = 2;
        const sampleRate = audioCtx.sampleRate;
        const reverbLength = sampleRate * reverbTime;
        const impulse = audioCtx.createBuffer(2, reverbLength, sampleRate);
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < reverbLength; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbLength, 2);
            }
        }
        convolver.buffer = impulse;
        
        // Wet/dry mix for reverb
        const reverbGain = audioCtx.createGain();
        reverbGain.gain.value = 0.3;
        convolver.connect(reverbGain);
        reverbGain.connect(masterGain);
        
        // Dry signal path
        const dryGain = audioCtx.createGain();
        dryGain.gain.value = 0.7;
        dryGain.connect(masterGain);
        
        // Deep bass synth
        function playBass() {
            const note = bassNotes[Math.floor(Math.random() * bassNotes.length)];
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.value = note;
            osc2.type = 'square';
            osc2.frequency.value = note * 0.5;
            
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            filter.Q.value = 5;
            
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.3);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
            
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(dryGain);
            
            osc.start();
            osc2.start();
            osc.stop(audioCtx.currentTime + 0.9);
            osc2.stop(audioCtx.currentTime + 0.9);
        }
        
        // Sparkling arpeggiator
        let arpIndex = 0;
        let arpPattern = [0, 2, 4, 7, 4, 2]; // Arp pattern indices
        function playArp() {
            const noteIdx = arpPattern[arpIndex % arpPattern.length];
            const note = arpNotes[noteIdx % arpNotes.length];
            arpIndex++;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'triangle';
            osc.frequency.value = note * (Math.random() > 0.8 ? 2 : 1);
            
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            
            osc.connect(gain);
            gain.connect(convolver);
            gain.connect(dryGain);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 0.35);
        }
        
        // Atmospheric pad
        let padOscs = [];
        function playPad() {
            // Clean up old pad
            padOscs.forEach(p => { try { p.osc.stop(); } catch(e){} });
            padOscs = [];
            
            const chord = [padNotes[0], padNotes[2], padNotes[3]]; // Am chord
            chord.forEach((note, i) => {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = note * 2;
                osc2.type = 'triangle';
                osc2.frequency.value = note * 2 + 1; // Slight detune for richness
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 2);
                gain.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime + 6);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 8);
                
                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(convolver);
                
                osc.start();
                osc2.start();
                osc.stop(audioCtx.currentTime + 8.5);
                osc2.stop(audioCtx.currentTime + 8.5);
                padOscs.push({osc, osc2});
            });
        }
        
        // Kick drum
        function playKick() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            
            osc.connect(gain);
            gain.connect(dryGain);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 0.35);
        }
        
        // Hi-hat
        function playHiHat() {
            const bufferSize = audioCtx.sampleRate * 0.05;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 8000;
            
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(dryGain);
            
            noise.start();
        }
        
        function startMusic() {
            if (musicPlaying) return;
            musicPlaying = true;
            
            // Bass every 800ms
            musicIntervals.push(setInterval(playBass, 800));
            
            // Arp every 200ms
            musicIntervals.push(setInterval(playArp, 200));
            
            // Pad every 8 seconds
            playPad();
            musicIntervals.push(setInterval(playPad, 8000));
            
            // Kick on beat (every 400ms)
            musicIntervals.push(setInterval(playKick, 400));
            
            // Hi-hat offbeat
            setTimeout(() => {
                musicIntervals.push(setInterval(playHiHat, 400));
            }, 200);
            
            // Random variation - change arp pattern occasionally
            musicIntervals.push(setInterval(() => {
                const patterns = [
                    [0, 2, 4, 7, 4, 2],
                    [0, 4, 2, 5, 7, 5],
                    [7, 5, 4, 2, 0, 2],
                    [0, 0, 4, 4, 7, 7]
                ];
                arpPattern = patterns[Math.floor(Math.random() * patterns.length)];
            }, 4000));
        }
        
        function stopMusic() {
            musicPlaying = false;
            musicIntervals.forEach(id => clearInterval(id));
            musicIntervals = [];
        }
        
        // Start music on user interaction (browser autoplay policy)
        document.addEventListener('click', function startAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            startMusic();
            document.removeEventListener('click', startAudio);
        }, { once: true });
        
        // Try to start immediately (may work on some browsers)
        setTimeout(() => {
            if (audioCtx.state === 'running') startMusic();
        }, 1000);
    </script>
<script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a12, 0.012);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a12);
        document.body.appendChild(renderer.domElement);
        
        // Ground with glowing grid
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x1a1a2e })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // Add visible grid lines
        const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x003344);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);
        
        // Lights - OPTIMIZED: Using stronger ambient + directional to compensate for fewer point lights
        scene.add(new THREE.AmbientLight(0x8888cc, 1.8));
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(10, 30, 10);
        scene.add(mainLight);
        const fillLight = new THREE.DirectionalLight(0x00ffff, 0.8);
        fillLight.position.set(-10, 20, -10);
        scene.add(fillLight);
        const backLight = new THREE.DirectionalLight(0xff00ff, 0.4);
        backLight.position.set(0, 10, -20);
        scene.add(backLight);
        
        // Window texture generator - Pre-generate textures to avoid memory leaks
        const windowTextureCache = [];
        const NUM_CACHED_TEXTURES = 5; // Reduced texture cache for memory
        
        function generateWindowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, 64, 128);
            const windowColors = ['#00ffff', '#ff00ff', '#ffff00', '#00ff00', '#ff6600', '#ffffff'];
            
            const numWindows = 2 + Math.floor(Math.random() * 2);
            const windowHeight = Math.floor(100 / numWindows);
            const windowWidth = 50;
            const margin = 7;
            
            for (let i = 0; i < numWindows; i++) {
                if (Math.random() > 0.15) {
                    const wColor = windowColors[Math.floor(Math.random() * windowColors.length)];
                    ctx.fillStyle = wColor;
                    ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                    const yPos = margin + i * (windowHeight + 4);
                    ctx.fillRect(margin, yPos, windowWidth, windowHeight - 8);
                    
                    ctx.fillStyle = '#1a1a3e';
                    ctx.globalAlpha = 1;
                    ctx.fillRect(margin + windowWidth/2 - 1, yPos, 2, windowHeight - 8);
                    if (numWindows <= 2) {
                        ctx.fillRect(margin, yPos + (windowHeight-8)/2 - 1, windowWidth, 2);
                    }
                }
            }
            ctx.globalAlpha = 1;
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Pre-generate texture pool
        for (let i = 0; i < NUM_CACHED_TEXTURES; i++) {
            windowTextureCache.push(generateWindowTexture());
        }
        
        function createWindowTexture() {
            return windowTextureCache[Math.floor(Math.random() * windowTextureCache.length)];
        }
        
        // Buildings - Grid-based city layout
        const buildings = [];
        const neonColors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff6600];
        // Manhattan-style blocks: longer north-south, shorter east-west
        const blockSizeX = 8; // Short east-west blocks (like Manhattan avenues)
        const blockSizeZ = 18; // Long north-south blocks (like Manhattan streets)
        const streetWidth = 5; // Wider streets
        const avenueWidth = 7; // Even wider avenues
        const gridSpacingX = blockSizeX + streetWidth;
        const gridSpacingZ = blockSizeZ + avenueWidth;
        
        // Manhattan-style streets with asphalt texture
        const streetMat = new THREE.MeshStandardMaterial({ color: 0x1a1a22, roughness: 0.9 });
        const avenueMat = new THREE.MeshStandardMaterial({ color: 0x1c1c25, roughness: 0.85 });
        const crosswalkMat = new THREE.MeshStandardMaterial({ color: 0xccccaa, roughness: 0.7 });
        const yellowLineMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0x332200 });
        
        // Create east-west streets (shorter blocks between)
        for (let i = -4; i <= 4; i++) {
            const street = new THREE.Mesh(new THREE.PlaneGeometry(150, streetWidth), streetMat);
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.02, i * gridSpacingZ);
            scene.add(street);
            
            // Yellow center line
            const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(150, 0.15), yellowLineMat);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.025, i * gridSpacingZ);
            scene.add(centerLine);
        }
        
        // Create north-south avenues (wider, like Manhattan avenues)
        for (let i = -5; i <= 5; i++) {
            const avenue = new THREE.Mesh(new THREE.PlaneGeometry(avenueWidth, 200), avenueMat);
            avenue.rotation.x = -Math.PI / 2;
            avenue.position.set(i * gridSpacingX, 0.02, 0);
            scene.add(avenue);
            
            // Double yellow lines for avenues
            const line1 = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 200), yellowLineMat);
            line1.rotation.x = -Math.PI / 2;
            line1.position.set(i * gridSpacingX - 0.2, 0.025, 0);
            scene.add(line1);
            const line2 = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 200), yellowLineMat);
            line2.rotation.x = -Math.PI / 2;
            line2.position.set(i * gridSpacingX + 0.2, 0.025, 0);
            scene.add(line2);
        }
        
        // Crosswalks at intersections
        for (let i = -4; i <= 4; i++) {
            for (let j = -5; j <= 5; j++) {
                // Crosswalk stripes
                for (let s = 0; s < 6; s++) {
                    const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.4, avenueWidth * 0.8), crosswalkMat);
                    stripe.rotation.x = -Math.PI / 2;
                    stripe.position.set(j * gridSpacingX, 0.03, i * gridSpacingZ + (s - 2.5) * 0.7);
                    scene.add(stripe);
                }
            }
        }
        
        // Street lights (Manhattan-style) - MINIMAL for GPU compatibility
        // Only 2 central street lights to avoid shader uniform overflow
        const centralLamp1 = new THREE.PointLight(0xffdd88, 2, 25);
        centralLamp1.position.set(5, 6, 5);
        scene.add(centralLamp1);
        const centralLamp2 = new THREE.PointLight(0xffdd88, 2, 25);
        centralLamp2.position.set(-5, 6, -5);
        scene.add(centralLamp2);
        
        // Place buildings in Manhattan-style city blocks
        for (let bx = -5; bx <= 5; bx++) {
            for (let bz = -4; bz <= 4; bz++) {
                // Skip more blocks for performance + variety (parks, plazas)
                if (Math.random() > 0.55) continue; // Reduced density for better performance
                
                const blockCenterX = bx * gridSpacingX;
                const blockCenterZ = bz * gridSpacingZ;
                
                // 1-3 buildings per Manhattan block (optimized for performance)
                const numBuildings = 1 + Math.floor(Math.random() * 3);
                for (let b = 0; b < numBuildings; b++) {
                    const h = 8 + Math.random() * 35; // Taller buildings
                    const wX = 2 + Math.random() * 2.5;
                    const wZ = 3 + Math.random() * 4; // Longer along the block
                    const windowTex = createWindowTexture();
                    windowTex.repeat.set(Math.ceil(wX/2), 1);
                    const buildingMat = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a3e,
                        map: windowTex,
                        emissive: 0x111122,
                        emissiveMap: windowTex,
                        emissiveIntensity: 0.8
                    });
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(wX, h, wZ),
                        buildingMat
                    );
                    // Position within the Manhattan block
                    const offsetX = (Math.random() - 0.5) * (blockSizeX - wX - 0.5);
                    const offsetZ = (Math.random() - 0.5) * (blockSizeZ - wZ - 1);
                    building.position.set(
                        blockCenterX + offsetX,
                        h / 2,
                        blockCenterZ + offsetZ
                    );
                    scene.add(building);
                    buildings.push(building);
                    
                    // Neon signs - DISABLED to prevent shader overflow
                    // Buildings use emissive materials instead for glow effect
                }
            }
        }
        
        // Humanoid creator function
        function createHumanoid(color, emissive = false, scale = 1) {
            const human = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: emissive ? color : 0x000000, 
                emissiveIntensity: emissive ? 0.6 : 0 
            });
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.22 * scale, 8, 8), mat); // Reduced segments
            head.position.y = 1.65 * scale;
            human.add(head);
            
            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.55 * scale, 0.2 * scale), mat);
            torso.position.y = 1.2 * scale;
            human.add(torso);
            
            // Hips
            const hips = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale, 0.2 * scale, 0.18 * scale), mat);
            hips.position.y = 0.85 * scale;
            human.add(hips);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.06 * scale, 0.05 * scale, 0.5 * scale, 8);
            const leftUpperArm = new THREE.Mesh(armGeo, mat);
            leftUpperArm.position.set(-0.28 * scale, 1.3 * scale, 0);
            leftUpperArm.rotation.z = 0.15;
            human.add(leftUpperArm);
            const rightUpperArm = new THREE.Mesh(armGeo, mat);
            rightUpperArm.position.set(0.28 * scale, 1.3 * scale, 0);
            rightUpperArm.rotation.z = -0.15;
            human.add(rightUpperArm);
            
            // Forearms
            const leftForearm = new THREE.Mesh(armGeo, mat);
            leftForearm.position.set(-0.32 * scale, 0.85 * scale, 0);
            human.add(leftForearm);
            const rightForearm = new THREE.Mesh(armGeo, mat);
            rightForearm.position.set(0.32 * scale, 0.85 * scale, 0);
            human.add(rightForearm);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08 * scale, 0.06 * scale, 0.45 * scale, 8);
            const leftThigh = new THREE.Mesh(legGeo, mat);
            leftThigh.position.set(-0.12 * scale, 0.55 * scale, 0);
            human.add(leftThigh);
            const rightThigh = new THREE.Mesh(legGeo, mat);
            rightThigh.position.set(0.12 * scale, 0.55 * scale, 0);
            human.add(rightThigh);
            
            // Calves
            const leftCalf = new THREE.Mesh(legGeo, mat);
            leftCalf.position.set(-0.12 * scale, 0.15 * scale, 0);
            human.add(leftCalf);
            const rightCalf = new THREE.Mesh(legGeo, mat);
            rightCalf.position.set(0.12 * scale, 0.15 * scale, 0);
            human.add(rightCalf);
            
            // Feet
            const footGeo = new THREE.BoxGeometry(0.1 * scale, 0.06 * scale, 0.18 * scale);
            const leftFoot = new THREE.Mesh(footGeo, mat);
            leftFoot.position.set(-0.12 * scale, 0.03 * scale, 0.04 * scale);
            human.add(leftFoot);
            const rightFoot = new THREE.Mesh(footGeo, mat);
            rightFoot.position.set(0.12 * scale, 0.03 * scale, 0.04 * scale);
            human.add(rightFoot);
            
            // Add laptop for busy NYC workers
            const laptopGroup = new THREE.Group();
            const laptopBase = new THREE.Mesh(
                new THREE.BoxGeometry(0.35 * scale, 0.02 * scale, 0.25 * scale),
                new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 })
            );
            laptopBase.position.y = 0.01 * scale;
            laptopGroup.add(laptopBase);
            
            // Glowing screen
            const screenMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, 
                emissive: 0x00ffff, 
                emissiveIntensity: 0.5 
            });
            const laptopScreen = new THREE.Mesh(
                new THREE.BoxGeometry(0.32 * scale, 0.22 * scale, 0.01 * scale),
                screenMat
            );
            laptopScreen.position.set(0, 0.12 * scale, -0.12 * scale);
            laptopScreen.rotation.x = -0.3;
            laptopGroup.add(laptopScreen);
            
            // Position laptop in front of body (held while walking)
            laptopGroup.position.set(0, 0.85 * scale, -0.35 * scale);
            laptopGroup.rotation.x = -0.4;
            human.add(laptopGroup);
            
            // Store limbs for animation
            human.userData.limbs = {
                leftUpperArm, rightUpperArm, leftForearm, rightForearm,
                leftThigh, rightThigh, leftCalf, rightCalf,
                laptop: laptopGroup
            };
            
            return human;
        }
        
        // Main character (the walker)
        const walker = createHumanoid(0x00ffff, true, 1.2);
        // Walker uses emissive material - no additional point light needed for GPU compatibility
        scene.add(walker);
        
        // Crowd (NPCs) - Now humanoid! Walking on sidewalks
        const crowd = [];
        const sidewalkOffsets = [-1.8, 1.8]; // Left and right sidewalks
        
        for (let i = 0; i < 24; i++) {
            const npcColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const npc = createHumanoid(npcColor, Math.random() > 0.5, 0.9 + Math.random() * 0.3);
            
            // Place NPCs on sidewalks along avenues or streets
            const onAvenue = Math.random() > 0.5;
            const sidewalkSide = sidewalkOffsets[Math.floor(Math.random() * 2)];
            
            if (onAvenue) {
                // Walking north-south along an avenue
                const avenueIndex = Math.floor(Math.random() * 8) - 4;
                npc.position.set(
                    avenueIndex * gridSpacingX + sidewalkSide,
                    0,
                    (Math.random() - 0.5) * 60
                );
                npc.userData.walkAxis = 'z'; // Walk along Z axis
                npc.userData.walkDirection = Math.random() > 0.5 ? 1 : -1;
                npc.userData.laneX = avenueIndex * gridSpacingX + sidewalkSide;
            } else {
                // Walking east-west along a street
                const streetIndex = Math.floor(Math.random() * 6) - 3;
                npc.position.set(
                    (Math.random() - 0.5) * 60,
                    0,
                    streetIndex * gridSpacingZ + sidewalkSide
                );
                npc.userData.walkAxis = 'x'; // Walk along X axis
                npc.userData.walkDirection = Math.random() > 0.5 ? 1 : -1;
                npc.userData.laneZ = streetIndex * gridSpacingZ + sidewalkSide;
            }
            
            npc.userData.speed = 0.015 + Math.random() * 0.015;
            npc.userData.walkPhase = Math.random() * Math.PI * 2;
            npc.userData.turningCooldown = 0;
            scene.add(npc);
            crowd.push(npc);
        }
        document.getElementById('count').textContent = crowd.length;
        
        // NINJA TURTLES! üê¢
        const turtleColors = [0x00ff00, 0xff0000, 0x0000ff, 0xff8800]; // Leo, Raph, Donnie, Mikey
        const turtleNames = ['Leonardo', 'Raphael', 'Donatello', 'Michelangelo'];
        const turtles = [];
        
        function createTurtle(color, name) {
            const turtle = new THREE.Group();
            const shellMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27, metalness: 0.3 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0x3d8b37 });
            const bandanaMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.8 });
            const swordMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1, emissive: 0xff0000, emissiveIntensity: 0.3 });
            
            // Shell (back)
            const shell = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 8), shellMat);
            shell.scale.set(1, 0.7, 1.2);
            shell.position.set(0, 0.9, 0.1);
            turtle.add(shell);
            
            // Body/chest
            const chest = new THREE.Mesh(new THREE.SphereGeometry(0.28, 10, 8), new THREE.MeshStandardMaterial({ color: 0xc4a35a }));
            chest.scale.set(1, 0.9, 0.7);
            chest.position.set(0, 0.9, -0.05);
            turtle.add(chest);
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 10, 10), skinMat);
            head.position.set(0, 1.25, -0.15);
            turtle.add(head);
            
            // Bandana
            const bandana = new THREE.Mesh(new THREE.TorusGeometry(0.18, 0.04, 8, 16), bandanaMat);
            bandana.position.set(0, 1.28, -0.15);
            bandana.rotation.x = Math.PI / 2;
            turtle.add(bandana);
            
            // Eyes
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
            leftEye.position.set(-0.08, 1.3, -0.3);
            turtle.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
            rightEye.position.set(0.08, 1.3, -0.3);
            turtle.add(rightEye);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.4, 8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.15, 0.4, 0);
            turtle.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.15, 0.4, 0);
            turtle.add(rightLeg);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.35, 8);
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.35, 0.95, 0);
            leftArm.rotation.z = Math.PI / 4;
            turtle.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.35, 0.95, 0);
            rightArm.rotation.z = -Math.PI / 4;
            turtle.add(rightArm);
            
            // DEADLY KATANA üó°Ô∏è
            const katanaGroup = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.6, 0.01), swordMat);
            blade.position.y = 0.35;
            katanaGroup.add(blade);
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.15, 8), new THREE.MeshStandardMaterial({ color: 0x4a2511 }));
            handle.position.y = 0;
            katanaGroup.add(handle);
            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 0.02), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
            guard.position.y = 0.08;
            katanaGroup.add(guard);
            katanaGroup.position.set(0.45, 0.95, 0);
            katanaGroup.rotation.z = -Math.PI / 3;
            turtle.add(katanaGroup);
            
            turtle.userData.name = name;
            turtle.userData.limbs = { leftLeg, rightLeg, leftArm, rightArm, katana: katanaGroup };
            turtle.userData.killCount = 0;
            turtle.userData.state = 'hidden'; // hidden, emerging, running, entering
            turtle.userData.targetManhole = null;
            turtle.userData.startManhole = null;
            turtle.userData.progress = 0;
            turtle.userData.walkPhase = 0;
            turtle.visible = false;
            
            return turtle;
        }
        
        // Create 4 turtles
        for (let i = 0; i < 4; i++) {
            const turtle = createTurtle(turtleColors[i], turtleNames[i]);
            scene.add(turtle);
            turtles.push(turtle);
        }
        
        // Turtle mission system
        let nextTurtleMission = 200; // Start first mission after a few seconds
        const dyingNPCs = [];
        let totalKills = 0;
        
        function updateKillCount() {
            totalKills++;
            document.getElementById('victims').textContent = totalKills;
            document.getElementById('count').textContent = crowd.length;
        }
        
        // NPC Respawn system - new citizens arrive after deaths!
        function spawnNewNPC() {
            const npcColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const npc = createHumanoid(npcColor, Math.random() > 0.5, 0.9 + Math.random() * 0.3);
            
            const onAvenue = Math.random() > 0.5;
            const sidewalkSide = sidewalkOffsets[Math.floor(Math.random() * 2)];
            
            if (onAvenue) {
                const avenueIndex = Math.floor(Math.random() * 8) - 4;
                npc.position.set(
                    avenueIndex * gridSpacingX + sidewalkSide,
                    0,
                    (Math.random() > 0.5 ? 1 : -1) * 35 // Spawn at edge
                );
                npc.userData.walkAxis = 'z';
                npc.userData.walkDirection = npc.position.z > 0 ? -1 : 1;
                npc.userData.laneX = avenueIndex * gridSpacingX + sidewalkSide;
            } else {
                const streetIndex = Math.floor(Math.random() * 6) - 3;
                npc.position.set(
                    (Math.random() > 0.5 ? 1 : -1) * 35,
                    0,
                    streetIndex * gridSpacingZ + sidewalkSide
                );
                npc.userData.walkAxis = 'x';
                npc.userData.walkDirection = npc.position.x > 0 ? -1 : 1;
                npc.userData.laneZ = streetIndex * gridSpacingZ + sidewalkSide;
            }
            
            npc.userData.speed = 0.015 + Math.random() * 0.015;
            npc.userData.walkPhase = Math.random() * Math.PI * 2;
            npc.userData.turningCooldown = 0;
            scene.add(npc);
            crowd.push(npc);
            document.getElementById('count').textContent = crowd.length;
        }
        
        // Attack camera system
        let attackCamActive = false;
        let attackCamTimer = 0;
        let attackCamTarget = null;
        let normalTimeScale = 1;
        let currentTimeScale = 1;
        
        function sliceNPC(npc, index, turtle) {
            npc.userData.isDying = true;
            
            // Create blood splatter effect
            const bloodGeom = new THREE.SphereGeometry(0.1, 6, 6);
            const bloodMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            for (let b = 0; b < 8; b++) {
                const blood = new THREE.Mesh(bloodGeom, bloodMat);
                blood.position.copy(npc.position);
                blood.position.y = 1;
                blood.position.x += (Math.random() - 0.5) * 0.5;
                blood.position.z += (Math.random() - 0.5) * 0.5;
                scene.add(blood);
                setTimeout(() => scene.remove(blood), 500 + Math.random() * 500);
            }
            
            // Create top half (head, torso, arms)
            const topHalf = new THREE.Group();
            const topMat = new THREE.MeshStandardMaterial({ 
                color: npc.children[0]?.material?.color || 0xff00ff, 
                transparent: true, 
                opacity: 1 
            });
            const topBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.2), topMat);
            topBody.position.y = 0.2;
            topHalf.add(topBody);
            const topHead = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), topMat);
            topHead.position.y = 0.5;
            topHalf.add(topHead);
            topHalf.position.copy(npc.position);
            topHalf.position.y = 1.2;
            scene.add(topHalf);
            
            // Create bottom half (hips, legs)
            const bottomHalf = new THREE.Group();
            const bottomMat = new THREE.MeshStandardMaterial({ 
                color: npc.children[0]?.material?.color || 0xff00ff, 
                transparent: true, 
                opacity: 1 
            });
            const hips = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.18), bottomMat);
            hips.position.y = 0.15;
            bottomHalf.add(hips);
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.05, 0.5, 8), bottomMat);
            leg1.position.set(-0.1, -0.2, 0);
            bottomHalf.add(leg1);
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.05, 0.5, 8), bottomMat);
            leg2.position.set(0.1, -0.2, 0);
            bottomHalf.add(leg2);
            bottomHalf.position.copy(npc.position);
            bottomHalf.position.y = 0.6;
            scene.add(bottomHalf);
            
            // Remove original NPC
            scene.remove(npc);
            crowd.splice(index, 1);
            
            // Track dying animation
            dyingNPCs.push({
                topHalf: topHalf,
                bottomHalf: bottomHalf,
                timer: 60,
                splitDir: Math.random() > 0.5 ? 1 : -1
            });
            
            // Update status
            document.getElementById('turtle-status').innerHTML = 'üíÄ ' + turtle.userData.name + ': SLICED A VICTIM! ‚ò†Ô∏è';
        }
        
        function startTurtleMission() {
            // Find available turtle
            const availableTurtle = turtles.find(t => t.userData.state === 'hidden');
            if (!availableTurtle || manholes.length < 2) return;
            
            // Pick random start and end manholes
            const startIdx = Math.floor(Math.random() * manholes.length);
            let endIdx = Math.floor(Math.random() * manholes.length);
            while (endIdx === startIdx) endIdx = Math.floor(Math.random() * manholes.length);
            
            availableTurtle.userData.startManhole = manholes[startIdx];
            availableTurtle.userData.targetManhole = manholes[endIdx];
            availableTurtle.userData.state = 'emerging';
            availableTurtle.userData.progress = 0;
            availableTurtle.position.copy(manholes[startIdx].position);
            availableTurtle.position.y = -1; // Start below ground
            availableTurtle.visible = true;
            
            document.getElementById('turtle-status').innerHTML = 'üê¢ ' + availableTurtle.userData.name + ': Emerging from sewer!';
        }
        
        // Realistic NYC manholes with steam vents
        const manholes = [];
        const steamParticles = [];
        
        // Create detailed manhole cover texture
        function createManholeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Base rusty metal
            ctx.fillStyle = '#3a3a40';
            ctx.beginPath();
            ctx.arc(64, 64, 60, 0, Math.PI * 2);
            ctx.fill();
            
            // Concentric grip rings
            ctx.strokeStyle = '#2a2a30';
            ctx.lineWidth = 3;
            for (let r = 15; r < 55; r += 12) {
                ctx.beginPath();
                ctx.arc(64, 64, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Grip pattern (radial lines)
            ctx.strokeStyle = '#252530';
            ctx.lineWidth = 2;
            for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
                ctx.beginPath();
                ctx.moveTo(64 + Math.cos(a) * 20, 64 + Math.sin(a) * 20);
                ctx.lineTo(64 + Math.cos(a) * 55, 64 + Math.sin(a) * 55);
                ctx.stroke();
            }
            
            // Center text area
            ctx.fillStyle = '#2d2d35';
            ctx.beginPath();
            ctx.arc(64, 64, 18, 0, Math.PI * 2);
            ctx.fill();
            
            // NYC text
            ctx.fillStyle = '#4a4a55';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('NYC', 64, 62);
            ctx.font = '6px Arial';
            ctx.fillText('SEWER', 64, 72);
            
            // Rust spots
            ctx.fillStyle = '#4a3020';
            for (let i = 0; i < 8; i++) {
                const rx = 20 + Math.random() * 88;
                const ry = 20 + Math.random() * 88;
                ctx.beginPath();
                ctx.arc(rx, ry, 2 + Math.random() * 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            return new THREE.CanvasTexture(canvas);
        }
        
        const manholeTexture = createManholeTexture();
        
        for (let i = 0; i < 12; i++) { // Reduced manholes for performance
            const manholeGroup = new THREE.Group();
            
            // Manhole rim (slightly larger, recessed)
            const rimGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.08, 24);
            const rimMat = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a32,
                metalness: 0.7,
                roughness: 0.6
            });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.position.y = -0.02;
            manholeGroup.add(rim);
            
            // Main cover with texture
            const coverGeo = new THREE.CylinderGeometry(0.48, 0.48, 0.06, 24);
            const coverMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a55,
                metalness: 0.8,
                roughness: 0.4,
                map: manholeTexture
            });
            const cover = new THREE.Mesh(coverGeo, coverMat);
            cover.position.y = 0.03;
            manholeGroup.add(cover);
            
            // Position on streets (at intersections or along avenues)
            const onAvenue = Math.random() > 0.5;
            let posX, posZ;
            if (onAvenue) {
                const avenueIndex = Math.floor(Math.random() * 10) - 5;
                posX = avenueIndex * gridSpacingX + (Math.random() - 0.5) * 2;
                posZ = (Math.random() - 0.5) * 80;
            } else {
                const streetIndex = Math.floor(Math.random() * 8) - 4;
                posX = (Math.random() - 0.5) * 80;
                posZ = streetIndex * gridSpacingZ + (Math.random() - 0.5) * 2;
            }
            
            manholeGroup.position.set(posX, 0.02, posZ);
            
            // Add steam vent effect to some manholes - No lights, just visual marker
            if (Math.random() > 0.7) {
                manholeGroup.userData.hasSteam = true;
                manholeGroup.userData.steamPhase = Math.random() * Math.PI * 2;
                // Steam visual only - no point light for performance
            }
            
            scene.add(manholeGroup);
            manholes.push(manholeGroup);
        }
        
        // Conversation system
        const conversations = {
            weather: [
                "Looks like digital rain tonight...",
                "The fog density is at 0.012 today!",
                "Perfect neon glow weather, huh?",
                "My sensors say 72% humidity.",
                "Remember when we had real clouds?"
            ],
            coffee: [
                "That synth-coffee was pure static!",
                "I need my morning byte-brew.",
                "Espresso.exe has stopped working...",
                "Coffee: the original debugging tool.",
                "404: Sleep not found. Need caffeine."
            ],
            nerdJokes: [
                "Why do programmers hate nature? Too many bugs.",
                "There are 10 types of people...",
                "I'd tell you a UDP joke but you might not get it.",
                "A SQL query walks into a bar, joins two tables...",
                "!false - it's funny because it's true.",
                "Recursion: see Recursion.",
                "I'm not anti-social, I'm just not user-friendly."
            ]
        };
        
        let activeConversation = null;
        let conversationTimer = 0;
        const bubbleEl = document.getElementById('speech-bubble');
        const bubbleText = document.getElementById('bubble-text');
        
        function startConversation(npc1, npc2) {
            const topics = Object.keys(conversations);
            const topic = topics[Math.floor(Math.random() * topics.length)];
            const lines = conversations[topic];
            const line = lines[Math.floor(Math.random() * lines.length)];
            
            activeConversation = {
                npc1: npc1,
                npc2: npc2,
                originalDir1: npc1.userData.direction,
                originalDir2: npc2.userData.direction,
                text: line,
                duration: 180 + Math.random() * 120
            };
            
            // Make them face each other
            const angle = Math.atan2(npc2.position.z - npc1.position.z, npc2.position.x - npc1.position.x);
            npc1.userData.direction = -10; // Stop moving
            npc2.userData.direction = -10;
            npc1.rotation.y = -angle + Math.PI/2;
            npc2.rotation.y = -angle - Math.PI/2;
            
            bubbleText.textContent = line;
            bubbleEl.style.display = 'block';
            conversationTimer = activeConversation.duration;
        }
        
        function checkForConversations() {
            if (activeConversation) return;
            if (Math.random() > 0.005) return; // Random chance per frame
            
            for (let i = 0; i < crowd.length; i++) {
                for (let j = i + 1; j < crowd.length; j++) {
                    const dist = crowd[i].position.distanceTo(crowd[j].position);
                    if (dist < 3 && dist > 1) {
                        startConversation(crowd[i], crowd[j]);
                        return;
                    }
                }
            }
        }
        
        // Frustum culling for performance optimization
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();
        
        function updateFrustum() {
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);
        }
        
        function isInView(object) {
            if (!object.geometry) return true;
            if (!object.geometry.boundingSphere) object.geometry.computeBoundingSphere();
            const sphere = object.geometry.boundingSphere.clone();
            sphere.applyMatrix4(object.matrixWorld);
            return frustum.intersectsSphere(sphere);
        }
        
        // Animation
        let time = 0;
        let cullCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016 * currentTimeScale;
            
            // Walker movement (figure-8 path)
            walker.position.x = Math.sin(time * 0.3) * 15;
            walker.position.z = Math.sin(time * 0.6) * 10;
            walker.rotation.y = Math.atan2(
                Math.cos(time * 0.3) * 15 * 0.3,
                Math.cos(time * 0.6) * 10 * 0.6
            );
            
            // Camera follows walker OR focuses on attack
            if (attackCamActive && attackCamTarget) {
                // Dramatic attack camera!
                const turtlePos = attackCamTarget.turtle.position;
                const victimPos = attackCamTarget.victimPos;
                const midX = (turtlePos.x + victimPos.x) / 2;
                const midZ = (turtlePos.z + victimPos.z) / 2;
                
                // Orbit around the action
                const camAngle = time * 2;
                camera.position.x = midX + Math.sin(camAngle) * 5;
                camera.position.y = 2.5;
                camera.position.z = midZ + Math.cos(camAngle) * 5;
                camera.lookAt(midX, 1, midZ);
                
                attackCamTimer--;
                if (attackCamTimer <= 0) {
                    attackCamActive = false;
                    attackCamTarget = null;
                    currentTimeScale = 1;
                }
            } else {
                camera.position.x = walker.position.x - 8;
                camera.position.y = 5;
                camera.position.z = walker.position.z + 8;
                camera.lookAt(walker.position.x, 1.5, walker.position.z);
            }
            
            // Update frustum for culling
            camera.updateMatrixWorld();
            updateFrustum();
            
            // Frustum cull buildings
            cullCount = 0;
            buildings.forEach(building => {
                const wasVisible = building.visible;
                building.visible = isInView(building);
                if (!building.visible) cullCount++;
            });
            
            // Frustum cull manholes - tighter radius for performance
            manholes.forEach(mh => {
                const dist = mh.position.distanceTo(camera.position);
                mh.visible = dist < 35; // Tighter distance culling
            });
            
            // Animate crowd with rectilinear Manhattan-style walking
            crowd.forEach(npc => {
                // Distance-based LOD: hide NPCs far from camera
                const distToCam = npc.position.distanceTo(camera.position);
                npc.visible = distToCam < 45;
                
                // Rectilinear movement along streets/avenues
                if (npc.userData.walkAxis === 'z') {
                    // Walking north-south
                    npc.position.z += npc.userData.walkDirection * npc.userData.speed;
                    npc.rotation.y = npc.userData.walkDirection > 0 ? 0 : Math.PI;
                    
                    // Turn around at boundaries or randomly turn at intersections
                    if (Math.abs(npc.position.z) > 35) {
                        npc.userData.walkDirection *= -1;
                    }
                    // Chance to turn at intersection
                    if (npc.userData.turningCooldown <= 0) {
                        for (let si = -4; si <= 4; si++) {
                            const streetZ = si * gridSpacingZ;
                            if (Math.abs(npc.position.z - streetZ) < 0.3 && Math.random() < 0.02) {
                                npc.userData.walkAxis = 'x';
                                npc.userData.walkDirection = Math.random() > 0.5 ? 1 : -1;
                                npc.userData.laneZ = streetZ + (Math.random() > 0.5 ? 1.8 : -1.8);
                                npc.position.z = npc.userData.laneZ;
                                npc.userData.turningCooldown = 100;
                                break;
                            }
                        }
                    }
                } else {
                    // Walking east-west
                    npc.position.x += npc.userData.walkDirection * npc.userData.speed;
                    npc.rotation.y = npc.userData.walkDirection > 0 ? Math.PI/2 : -Math.PI/2;
                    
                    if (Math.abs(npc.position.x) > 35) {
                        npc.userData.walkDirection *= -1;
                    }
                    // Chance to turn at intersection
                    if (npc.userData.turningCooldown <= 0) {
                        for (let ai = -5; ai <= 5; ai++) {
                            const avenueX = ai * gridSpacingX;
                            if (Math.abs(npc.position.x - avenueX) < 0.3 && Math.random() < 0.02) {
                                npc.userData.walkAxis = 'z';
                                npc.userData.walkDirection = Math.random() > 0.5 ? 1 : -1;
                                npc.userData.laneX = avenueX + (Math.random() > 0.5 ? 1.8 : -1.8);
                                npc.position.x = npc.userData.laneX;
                                npc.userData.turningCooldown = 100;
                                break;
                            }
                        }
                    }
                }
                
                if (npc.userData.turningCooldown > 0) npc.userData.turningCooldown--;
                
                // Walking animation with laptop typing
                if (npc.userData.limbs) {
                    npc.userData.walkPhase += npc.userData.speed * 8;
                    const swing = Math.sin(npc.userData.walkPhase) * 0.4;
                    npc.userData.limbs.leftThigh.rotation.x = swing;
                    npc.userData.limbs.rightThigh.rotation.x = -swing;
                    // Arms bent forward to hold laptop
                    npc.userData.limbs.leftUpperArm.rotation.x = -0.8;
                    npc.userData.limbs.rightUpperArm.rotation.x = -0.8;
                    npc.userData.limbs.leftUpperArm.rotation.z = 0.3;
                    npc.userData.limbs.rightUpperArm.rotation.z = -0.3;
                    // Laptop bobs slightly with walking
                    if (npc.userData.limbs.laptop) {
                        npc.userData.limbs.laptop.position.y = 0.85 + Math.sin(npc.userData.walkPhase * 2) * 0.02;
                        // Subtle typing vibration
                        npc.userData.limbs.laptop.rotation.z = Math.sin(npc.userData.walkPhase * 8) * 0.01;
                    }
                }
            });
            
            // Animate walker's walking
            if (walker.userData.limbs) {
                const walkerSwing = Math.sin(time * 4) * 0.5;
                walker.userData.limbs.leftThigh.rotation.x = walkerSwing;
                walker.userData.limbs.rightThigh.rotation.x = -walkerSwing;
                walker.userData.limbs.leftUpperArm.rotation.x = -walkerSwing * 0.6;
                walker.userData.limbs.rightUpperArm.rotation.x = walkerSwing * 0.6;
            }
            
            // Check for NPC conversations
            checkForConversations();
            
            // Update active conversation
            if (activeConversation) {
                conversationTimer--;
                
                // Position bubble above the NPCs
                const midPoint = new THREE.Vector3().addVectors(
                    activeConversation.npc1.position,
                    activeConversation.npc2.position
                ).multiplyScalar(0.5);
                midPoint.y = 2.5;
                
                const screenPos = midPoint.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                
                bubbleEl.style.left = (x - 100) + 'px';
                bubbleEl.style.top = (y - 60) + 'px';
                
                // Stop walking animation during conversation
                if (activeConversation.npc1.userData.limbs) {
                    activeConversation.npc1.userData.limbs.leftThigh.rotation.x = 0;
                    activeConversation.npc1.userData.limbs.rightThigh.rotation.x = 0;
                }
                if (activeConversation.npc2.userData.limbs) {
                    activeConversation.npc2.userData.limbs.leftThigh.rotation.x = 0;
                    activeConversation.npc2.userData.limbs.rightThigh.rotation.x = 0;
                }
                
                if (conversationTimer <= 0) {
                    // End conversation, resume walking
                    activeConversation.npc1.userData.direction = Math.random() * Math.PI * 2;
                    activeConversation.npc2.userData.direction = Math.random() * Math.PI * 2;
                    bubbleEl.style.display = 'none';
                    activeConversation = null;
                }
            }
            
            // NPC death/slice animation system
            dyingNPCs.forEach((dying, idx) => {
                dying.timer--;
                // Separate the halves
                if (dying.topHalf && dying.bottomHalf) {
                    dying.topHalf.position.y += 0.05;
                    dying.topHalf.rotation.x += 0.1;
                    dying.topHalf.position.x += dying.splitDir * 0.02;
                    dying.bottomHalf.position.y -= 0.02;
                    dying.bottomHalf.rotation.z += 0.05;
                    dying.bottomHalf.position.x -= dying.splitDir * 0.02;
                    // Fade out
                    const opacity = dying.timer / 60;
                    dying.topHalf.children.forEach(c => {
                        if (c.material) c.material.opacity = opacity;
                    });
                    dying.bottomHalf.children.forEach(c => {
                        if (c.material) c.material.opacity = opacity;
                    });
                }
                if (dying.timer <= 0) {
                    scene.remove(dying.topHalf);
                    scene.remove(dying.bottomHalf);
                    dyingNPCs.splice(idx, 1);
                }
            });
            
            // Animate Ninja Turtles
            nextTurtleMission--;
            if (nextTurtleMission <= 0) {
                startTurtleMission();
                nextTurtleMission = 400 + Math.random() * 300; // Next mission in 6-12 seconds
            }
            
            turtles.forEach(turtle => {
                if (turtle.userData.state === 'emerging') {
                    turtle.userData.progress += 0.02;
                    turtle.position.y = -1 + turtle.userData.progress * 1.5;
                    if (turtle.userData.progress >= 1) {
                        turtle.userData.state = 'running';
                        turtle.userData.progress = 0;
                        document.getElementById('turtle-status').innerHTML = 'üíÄ ' + turtle.userData.name + ': HUNTING FOR PREY!';
                    }
                } else if (turtle.userData.state === 'running') {
                    const target = turtle.userData.targetManhole.position;
                    const dx = target.x - turtle.position.x;
                    const dz = target.z - turtle.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist > 0.5) {
                        const speed = 0.15; // Fast ninja speed!
                        turtle.position.x += (dx / dist) * speed;
                        turtle.position.z += (dz / dist) * speed;
                        turtle.rotation.y = Math.atan2(dx, dz);
                        
                        // Running animation with sword swing
                        turtle.userData.walkPhase += 0.4;
                        const swing = Math.sin(turtle.userData.walkPhase) * 0.6;
                        turtle.userData.limbs.leftLeg.rotation.x = swing;
                        turtle.userData.limbs.rightLeg.rotation.x = -swing;
                        turtle.userData.limbs.leftArm.rotation.x = -swing * 0.5;
                        turtle.userData.limbs.rightArm.rotation.x = swing * 0.5;
                        // Menacing sword swing
                        if (turtle.userData.limbs.katana) {
                            turtle.userData.limbs.katana.rotation.z = -Math.PI / 3 + Math.sin(turtle.userData.walkPhase * 2) * 0.3;
                        }
                        
                        // CHECK FOR VICTIMS üíÄ
                        for (let ci = crowd.length - 1; ci >= 0; ci--) {
                            const victim = crowd[ci];
                            if (victim.userData.isDying) continue;
                            const victimDist = turtle.position.distanceTo(victim.position);
                            if (victimDist < 1.5) {
                                // SLICE THEM IN HALF!
                                // Activate dramatic attack camera!
                                attackCamActive = true;
                                attackCamTimer = 90; // 1.5 seconds of drama
                                attackCamTarget = { turtle: turtle, victimPos: victim.position.clone() };
                                currentTimeScale = 0.3; // Slow motion!
                                
                                sliceNPC(victim, ci, turtle);
                                turtle.userData.killCount++;
                                updateKillCount();
                                
                                // Schedule respawn after 3-5 seconds
                                setTimeout(spawnNewNPC, 3000 + Math.random() * 2000);
                            }
                        }
                    } else {
                        turtle.userData.state = 'entering';
                        turtle.userData.progress = 0;
                        document.getElementById('turtle-status').innerHTML = 'üíÄ ' + turtle.userData.name + ': Retreating to shadows...';
                    }
                } else if (turtle.userData.state === 'entering') {
                    turtle.userData.progress += 0.025;
                    turtle.position.y = 0.5 - turtle.userData.progress * 1.5;
                    if (turtle.userData.progress >= 1) {
                        turtle.userData.state = 'hidden';
                        turtle.visible = false;
                        document.getElementById('turtle-status').innerHTML = 'üê¢ EVIL Ninja Turtles: Patrolling sewers üíÄ';
                    }
                }
            });
            
            // Steam manholes visual effect (no lights)
            manholes.forEach(mh => {
                if (mh.userData.hasSteam) {
                    mh.userData.steamPhase += 0.05;
                }
            });
            
            // Update cull stats in debug
            document.getElementById('cull-stats').textContent = cullCount + ' buildings hidden';
            
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Cleanup on page unload to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            stopMusic();
            if (audioCtx.state !== 'closed') audioCtx.close();
            renderer.dispose();
            windowTextureCache.forEach(tex => tex.dispose());
            manholeTexture.dispose();
        });
    </script>
</body>
</html>