<!DOCTYPE html>

<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<title>City Walker</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a0a12; }
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        #info h1 { font-size: 24px; margin-bottom: 5px; }
        #population {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #ff00ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-shadow: 0 0 8px #ff00ff;
            z-index: 100;
        }
        #community-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.7;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="info">
<h1>üåÉ CITY WALKER</h1>
<span>Follow the journey through neon streets</span>
</div>
<div id="population">CITIZENS: <span id="count">0</span></div>
<div id="community-zone">üó£Ô∏è Citizens chatting | üï≥Ô∏è Watch your step!</div>
<div id="speech-bubble" style="position:absolute;display:none;background:rgba(0,0,0,0.85);color:#fff;font-family:'Courier New',monospace;font-size:12px;padding:10px 15px;border-radius:10px;border:2px solid #00ffff;max-width:250px;z-index:200;pointer-events:none;box-shadow:0 0 15px rgba(0,255,255,0.5);"><span id="bubble-text"></span></div>
<div id="debug" style="position:absolute;top:60px;left:20px;color:#00ff00;font-family:monospace;font-size:11px;z-index:100;background:rgba(0,0,0,0.5);padding:8px;border:1px solid #00ff00;">üîß DEBUG: Scene Active<br/>Grid City: 7x7 blocks | NPCs: 30<br/>Renderer: WebGL | Streets: Active</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a12, 0.012);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a12);
        document.body.appendChild(renderer.domElement);
        
        // Ground with glowing grid
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x1a1a2e })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // Add visible grid lines
        const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x003344);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);
        
        // Lights - ENHANCED FOR VISIBILITY
        scene.add(new THREE.AmbientLight(0x6666aa, 1.2));
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(10, 30, 10);
        scene.add(mainLight);
        const fillLight = new THREE.DirectionalLight(0x00ffff, 0.5);
        fillLight.position.set(-10, 20, -10);
        scene.add(fillLight);
        
        // Window texture generator - Large industrial windows (2-3 per face)
        function createWindowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, 64, 128);
            const windowColors = ['#00ffff', '#ff00ff', '#ffff00', '#00ff00', '#ff6600', '#ffffff'];
            
            // 2-3 large windows per building face
            const numWindows = 2 + Math.floor(Math.random() * 2);
            const windowHeight = Math.floor(100 / numWindows);
            const windowWidth = 50;
            const margin = 7;
            
            for (let i = 0; i < numWindows; i++) {
                if (Math.random() > 0.15) { // Most windows lit
                    const wColor = windowColors[Math.floor(Math.random() * windowColors.length)];
                    ctx.fillStyle = wColor;
                    ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                    const yPos = margin + i * (windowHeight + 4);
                    ctx.fillRect(margin, yPos, windowWidth, windowHeight - 8);
                    
                    // Window frame/divider
                    ctx.fillStyle = '#1a1a3e';
                    ctx.globalAlpha = 1;
                    ctx.fillRect(margin + windowWidth/2 - 1, yPos, 2, windowHeight - 8);
                    if (numWindows <= 2) {
                        ctx.fillRect(margin, yPos + (windowHeight-8)/2 - 1, windowWidth, 2);
                    }
                }
            }
            ctx.globalAlpha = 1;
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Buildings - Grid-based city layout
        const buildings = [];
        const neonColors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff6600];
        const blockSize = 12; // Size of each city block
        const streetWidth = 4; // Width of streets
        const gridSpacing = blockSize + streetWidth;
        
        // Create streets (darker ground strips)
        const streetMat = new THREE.MeshStandardMaterial({ color: 0x222233 });
        for (let i = -3; i <= 3; i++) {
            // Horizontal streets
            const hStreet = new THREE.Mesh(new THREE.PlaneGeometry(100, streetWidth), streetMat);
            hStreet.rotation.x = -Math.PI / 2;
            hStreet.position.set(0, 0.02, i * gridSpacing);
            scene.add(hStreet);
            // Vertical streets
            const vStreet = new THREE.Mesh(new THREE.PlaneGeometry(streetWidth, 100), streetMat);
            vStreet.rotation.x = -Math.PI / 2;
            vStreet.position.set(i * gridSpacing, 0.02, 0);
            scene.add(vStreet);
            
            // Street lights along streets
            for (let j = -3; j <= 3; j++) {
                if (Math.random() > 0.3) {
                    const lampPost = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.1, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444466 })
                    );
                    lampPost.position.set(i * gridSpacing + streetWidth/2 + 0.5, 2, j * gridSpacing + streetWidth/2);
                    scene.add(lampPost);
                    const lamp = new THREE.PointLight(0xffaa55, 1.5, 8);
                    lamp.position.copy(lampPost.position);
                    lamp.position.y = 4.2;
                    scene.add(lamp);
                }
            }
        }
        
        // Place buildings in city blocks (not on streets)
        for (let bx = -3; bx <= 3; bx++) {
            for (let bz = -3; bz <= 3; bz++) {
                // Skip some blocks for variety (parks, plazas)
                if (Math.random() > 0.85) continue;
                
                const blockCenterX = bx * gridSpacing;
                const blockCenterZ = bz * gridSpacing;
                
                // 1-4 buildings per block
                const numBuildings = 1 + Math.floor(Math.random() * 4);
                for (let b = 0; b < numBuildings; b++) {
                    const h = 5 + Math.random() * 25;
                    const w = 2 + Math.random() * 3;
                    const windowTex = createWindowTexture();
                    windowTex.repeat.set(Math.ceil(w/3), 1);
                    const buildingMat = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a3e,
                        map: windowTex,
                        emissive: 0x111122,
                        emissiveMap: windowTex,
                        emissiveIntensity: 0.8
                    });
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(w, h, w),
                        buildingMat
                    );
                    // Position within the block (avoiding edges/streets)
                    const offsetX = (Math.random() - 0.5) * (blockSize - w - 1);
                    const offsetZ = (Math.random() - 0.5) * (blockSize - w - 1);
                    building.position.set(
                        blockCenterX + offsetX,
                        h / 2,
                        blockCenterZ + offsetZ
                    );
                    scene.add(building);
                    buildings.push(building);
                    
                    // Neon signs
                    if (Math.random() > 0.4) {
                        const neon = new THREE.PointLight(neonColors[Math.floor(Math.random() * neonColors.length)], 2, 10);
                        neon.position.copy(building.position);
                        neon.position.y = h * 0.6;
                        scene.add(neon);
                    }
                }
            }
        }
        
        // Humanoid creator function
        function createHumanoid(color, emissive = false, scale = 1) {
            const human = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: emissive ? color : 0x000000, 
                emissiveIntensity: emissive ? 0.6 : 0 
            });
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.22 * scale, 12, 12), mat);
            head.position.y = 1.65 * scale;
            human.add(head);
            
            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.55 * scale, 0.2 * scale), mat);
            torso.position.y = 1.2 * scale;
            human.add(torso);
            
            // Hips
            const hips = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale, 0.2 * scale, 0.18 * scale), mat);
            hips.position.y = 0.85 * scale;
            human.add(hips);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.06 * scale, 0.05 * scale, 0.5 * scale, 8);
            const leftUpperArm = new THREE.Mesh(armGeo, mat);
            leftUpperArm.position.set(-0.28 * scale, 1.3 * scale, 0);
            leftUpperArm.rotation.z = 0.15;
            human.add(leftUpperArm);
            const rightUpperArm = new THREE.Mesh(armGeo, mat);
            rightUpperArm.position.set(0.28 * scale, 1.3 * scale, 0);
            rightUpperArm.rotation.z = -0.15;
            human.add(rightUpperArm);
            
            // Forearms
            const leftForearm = new THREE.Mesh(armGeo, mat);
            leftForearm.position.set(-0.32 * scale, 0.85 * scale, 0);
            human.add(leftForearm);
            const rightForearm = new THREE.Mesh(armGeo, mat);
            rightForearm.position.set(0.32 * scale, 0.85 * scale, 0);
            human.add(rightForearm);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08 * scale, 0.06 * scale, 0.45 * scale, 8);
            const leftThigh = new THREE.Mesh(legGeo, mat);
            leftThigh.position.set(-0.12 * scale, 0.55 * scale, 0);
            human.add(leftThigh);
            const rightThigh = new THREE.Mesh(legGeo, mat);
            rightThigh.position.set(0.12 * scale, 0.55 * scale, 0);
            human.add(rightThigh);
            
            // Calves
            const leftCalf = new THREE.Mesh(legGeo, mat);
            leftCalf.position.set(-0.12 * scale, 0.15 * scale, 0);
            human.add(leftCalf);
            const rightCalf = new THREE.Mesh(legGeo, mat);
            rightCalf.position.set(0.12 * scale, 0.15 * scale, 0);
            human.add(rightCalf);
            
            // Feet
            const footGeo = new THREE.BoxGeometry(0.1 * scale, 0.06 * scale, 0.18 * scale);
            const leftFoot = new THREE.Mesh(footGeo, mat);
            leftFoot.position.set(-0.12 * scale, 0.03 * scale, 0.04 * scale);
            human.add(leftFoot);
            const rightFoot = new THREE.Mesh(footGeo, mat);
            rightFoot.position.set(0.12 * scale, 0.03 * scale, 0.04 * scale);
            human.add(rightFoot);
            
            // Store limbs for animation
            human.userData.limbs = {
                leftUpperArm, rightUpperArm, leftForearm, rightForearm,
                leftThigh, rightThigh, leftCalf, rightCalf
            };
            
            return human;
        }
        
        // Main character (the walker)
        const walker = createHumanoid(0x00ffff, true, 1.2);
        // Add glow light to walker
        const walkerGlow = new THREE.PointLight(0x00ffff, 3, 8);
        walkerGlow.position.y = 1;
        walker.add(walkerGlow);
        scene.add(walker);
        
        // Crowd (NPCs) - Now humanoid!
        const crowd = [];
        for (let i = 0; i < 30; i++) {
            const npcColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            const npc = createHumanoid(npcColor, Math.random() > 0.5, 0.9 + Math.random() * 0.3);
            npc.position.set(
                (Math.random() - 0.5) * 40,
                0,
                (Math.random() - 0.5) * 40
            );
            npc.userData.speed = 0.01 + Math.random() * 0.02;
            npc.userData.direction = Math.random() * Math.PI * 2;
            npc.userData.walkPhase = Math.random() * Math.PI * 2;
            scene.add(npc);
            crowd.push(npc);
        }
        document.getElementById('count').textContent = crowd.length;
        
        // Manholes scattered around the city
        const manholes = [];
        const manholeGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 16);
        const manholeMat = new THREE.MeshStandardMaterial({ 
            color: 0x333344,
            metalness: 0.8,
            roughness: 0.3
        });
        for (let i = 0; i < 25; i++) {
            const manhole = new THREE.Mesh(manholeGeo, manholeMat);
            manhole.position.set(
                Math.round((Math.random() - 0.5) * 60 / 4) * 4,
                0.03,
                Math.round((Math.random() - 0.5) * 60 / 4) * 4
            );
            // Add manhole cover detail ring
            const ringGeo = new THREE.RingGeometry(0.35, 0.45, 16);
            const ringMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x003333, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.03;
            manhole.add(ring);
            scene.add(manhole);
            manholes.push(manhole);
        }
        
        // Conversation system
        const conversations = {
            weather: [
                "Looks like digital rain tonight...",
                "The fog density is at 0.012 today!",
                "Perfect neon glow weather, huh?",
                "My sensors say 72% humidity.",
                "Remember when we had real clouds?"
            ],
            coffee: [
                "That synth-coffee was pure static!",
                "I need my morning byte-brew.",
                "Espresso.exe has stopped working...",
                "Coffee: the original debugging tool.",
                "404: Sleep not found. Need caffeine."
            ],
            nerdJokes: [
                "Why do programmers hate nature? Too many bugs.",
                "There are 10 types of people...",
                "I'd tell you a UDP joke but you might not get it.",
                "A SQL query walks into a bar, joins two tables...",
                "!false - it's funny because it's true.",
                "Recursion: see Recursion.",
                "I'm not anti-social, I'm just not user-friendly."
            ]
        };
        
        let activeConversation = null;
        let conversationTimer = 0;
        const bubbleEl = document.getElementById('speech-bubble');
        const bubbleText = document.getElementById('bubble-text');
        
        function startConversation(npc1, npc2) {
            const topics = Object.keys(conversations);
            const topic = topics[Math.floor(Math.random() * topics.length)];
            const lines = conversations[topic];
            const line = lines[Math.floor(Math.random() * lines.length)];
            
            activeConversation = {
                npc1: npc1,
                npc2: npc2,
                originalDir1: npc1.userData.direction,
                originalDir2: npc2.userData.direction,
                text: line,
                duration: 180 + Math.random() * 120
            };
            
            // Make them face each other
            const angle = Math.atan2(npc2.position.z - npc1.position.z, npc2.position.x - npc1.position.x);
            npc1.userData.direction = -10; // Stop moving
            npc2.userData.direction = -10;
            npc1.rotation.y = -angle + Math.PI/2;
            npc2.rotation.y = -angle - Math.PI/2;
            
            bubbleText.textContent = line;
            bubbleEl.style.display = 'block';
            conversationTimer = activeConversation.duration;
        }
        
        function checkForConversations() {
            if (activeConversation) return;
            if (Math.random() > 0.005) return; // Random chance per frame
            
            for (let i = 0; i < crowd.length; i++) {
                for (let j = i + 1; j < crowd.length; j++) {
                    const dist = crowd[i].position.distanceTo(crowd[j].position);
                    if (dist < 3 && dist > 1) {
                        startConversation(crowd[i], crowd[j]);
                        return;
                    }
                }
            }
        }
        
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            // Walker movement (figure-8 path)
            walker.position.x = Math.sin(time * 0.3) * 15;
            walker.position.z = Math.sin(time * 0.6) * 10;
            walker.rotation.y = Math.atan2(
                Math.cos(time * 0.3) * 15 * 0.3,
                Math.cos(time * 0.6) * 10 * 0.6
            );
            
            // Camera follows walker
            camera.position.x = walker.position.x - 8;
            camera.position.y = 5;
            camera.position.z = walker.position.z + 8;
            camera.lookAt(walker.position.x, 1.5, walker.position.z);
            
            // Animate crowd with walking motion
            crowd.forEach(npc => {
                npc.position.x += Math.cos(npc.userData.direction) * npc.userData.speed;
                npc.position.z += Math.sin(npc.userData.direction) * npc.userData.speed;
                npc.rotation.y = -npc.userData.direction + Math.PI/2;
                if (Math.abs(npc.position.x) > 30 || Math.abs(npc.position.z) > 30) {
                    npc.userData.direction += Math.PI;
                }
                // Walking animation
                if (npc.userData.limbs) {
                    npc.userData.walkPhase += npc.userData.speed * 8;
                    const swing = Math.sin(npc.userData.walkPhase) * 0.4;
                    npc.userData.limbs.leftThigh.rotation.x = swing;
                    npc.userData.limbs.rightThigh.rotation.x = -swing;
                    npc.userData.limbs.leftUpperArm.rotation.x = -swing * 0.6;
                    npc.userData.limbs.rightUpperArm.rotation.x = swing * 0.6;
                }
            });
            
            // Animate walker's walking
            if (walker.userData.limbs) {
                const walkerSwing = Math.sin(time * 4) * 0.5;
                walker.userData.limbs.leftThigh.rotation.x = walkerSwing;
                walker.userData.limbs.rightThigh.rotation.x = -walkerSwing;
                walker.userData.limbs.leftUpperArm.rotation.x = -walkerSwing * 0.6;
                walker.userData.limbs.rightUpperArm.rotation.x = walkerSwing * 0.6;
            }
            
            // Check for NPC conversations
            checkForConversations();
            
            // Update active conversation
            if (activeConversation) {
                conversationTimer--;
                
                // Position bubble above the NPCs
                const midPoint = new THREE.Vector3().addVectors(
                    activeConversation.npc1.position,
                    activeConversation.npc2.position
                ).multiplyScalar(0.5);
                midPoint.y = 2.5;
                
                const screenPos = midPoint.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                
                bubbleEl.style.left = (x - 100) + 'px';
                bubbleEl.style.top = (y - 60) + 'px';
                
                // Stop walking animation during conversation
                if (activeConversation.npc1.userData.limbs) {
                    activeConversation.npc1.userData.limbs.leftThigh.rotation.x = 0;
                    activeConversation.npc1.userData.limbs.rightThigh.rotation.x = 0;
                }
                if (activeConversation.npc2.userData.limbs) {
                    activeConversation.npc2.userData.limbs.leftThigh.rotation.x = 0;
                    activeConversation.npc2.userData.limbs.rightThigh.rotation.x = 0;
                }
                
                if (conversationTimer <= 0) {
                    // End conversation, resume walking
                    activeConversation.npc1.userData.direction = Math.random() * Math.PI * 2;
                    activeConversation.npc2.userData.direction = Math.random() * Math.PI * 2;
                    bubbleEl.style.display = 'none';
                    activeConversation = null;
                }
            }
            
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>